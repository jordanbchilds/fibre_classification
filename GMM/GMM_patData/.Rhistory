output = coda.samples(model=model, variable.names=c("mu", "tau","Y_syn","z","probdiff"),
n.iter=MCMCUpdates_Report, thin=MCMCUpdates_Thin)
output_priorpred = coda.samples(model=model_priorpred,
variable.names=c("mu", "tau","Y_syn","z","probdiff"),
n.iter=MCMCUpdates_Report, thin=MCMCUpdates_Thin)
MCMCoutput = output[,c("mu[1,1]","mu[1,2]","mu[2,1]","mu[2,2]",
"tau[1,1,1]","tau[1,2,1]","tau[2,1,1]","tau[2,2,1]",
"tau[1,1,2]","tau[1,2,2]","tau[2,1,2]","tau[2,2,2]",
"probdiff[1]", "probdiff[2]","probdiff[3]","probdiff[4]",
"probdiff[5]","probdiff[6]","probdiff[7]","probdiff[8]",
"probdiff[9]","probdiff[10]","Y_syn[1]", "Y_syn[2]")]
posterior = as.data.frame(output[[1]])
prior = as.data.frame(output_priorpred[[1]])
classifs = colMeans( posterior[, grepl('z', colnames(posterior))] )
colnames(posterior) = colnames(output[[1]])
colnames(prior) = colnames(output_priorpred[[1]])
pat_ind = c(0,N)
pat_ind = cumsum(pat_ind)
for(i in 1:length(N)){
pat = c('CTRL', pts)[i]
class_pat = classifs[(pat_ind[i]+1):pat_ind[i+1]]
write.table(as.numeric(classifs),file.path("Output/Output_allData",paste(outroot, pts[i], "CLASS.txt", sep='__')),
row.names=FALSE,quote=FALSE,col.names=FALSE)
data_pat = data_chan[(pat_ind[i]+1):pat_ind[i+1], ]
pdf(file.path("PDF/PDF_allData/classification", paste(outroot,".pdf")), width=14,height=8.5)
if( pat=='CTRL'){
priorpost( data=data_pat, prior=prior, posterior=posterior,
classifs=class_pat, title=paste(froot, pat[i], chan))
} else {
priorpost( data=data_pat, prior=prior, posterior=posterior, ctrl=data_ctrl,
classifs=class_pat, title=paste(froot, pat[i], chan))
}
pdf(file.path("PDF/PDF_allData/MCMC_output", paste(outroot,".pdf")), width=14,height=8.5)
dev.off()
}
write.table(posterior[,c("mu[1,1]","mu[1,2]","mu[2,1]","mu[2,2]",
"tau[1,1,1]","tau[1,2,1]","tau[2,1,1]","tau[2,2,1]",
"tau[1,1,2]","tau[1,2,2]","tau[2,1,2]","tau[2,2,2]",
"probdiff[1]","probdiff[2]","probdiff[3]","probdiff[4]",
"probdiff[5]","probdiff[6]","probdiff[7]","probdiff[8]",
"probdiff[9]","probdiff[10]","Y_syn[1]", "Y_syn[2]")],
posterior_file, row.names=FALSE, quote=FALSE)
}
# for( chan in imc_chan[-!(imc_chan == mitochan)]){
for( chan in c('NDUFB8')){
outroot = paste( froot, chan, sep='__')
posterior_file = file.path("Output/Output_allData", paste(outroot, "__POSTERIOR.txt") )
# dataset with only the current protein and VDAC1
data_chan = imcDat[(imcDat$channel==chan)|(imcDat$channel==mitochan),]
# control data for chan
control = imcDat[(imcDat$patient_type=='control')&(imcDat$type=='mean intensity'), ]
Xctrl = log(control$value[control$channel==mitochan])
Yctrl = log(control$value[control$channel==chan])
Nctrl = length(Yctrl)
Xchan = Xctrl
Ychan = Yctrl
patient_id = rep('control', Nctrl)
data_ctrl = data.frame(Xctrl, Yctrl,  rep('control', Nctrl))
colnames(data_ctrl) = c(mitochan, chan, 'patient')
N = double(10) # store the number of observations per patient
N[1] = Nctrl
for( j in 1:length(pts) ){
# all the patient data for chan
patient = imcDat[(imcDat$patient_id==pts[j])&(imcDat$type=="mean intensity"), ]
# patient data
Xpat = log(patient$value[patient$channel==mitochan])
Ypat = log(patient$value[patient$channel==chan])
Npat = length(Xpat)
# add patient data to data matrix
Xchan = c(Xchan, Xpat)
Ychan = c(Ychan, Ypat)
patient_id = c(patient_id, rep(paste(pts[j]), Npat) )
N[j+1] = Npat
}
# make data frame from data matrix
data_chan = data.frame(Xchan, Ychan, patient_id)
colnames(data_chan) = c(mitochan, chan, 'patient')
# saving output for mcmc
Ychan = data_chan[,c(mitochan, chan)]
is_control = as.numeric( patient_id=="control" )
# row index for each change in patient
con_pts = c('control', pts)
pat_index = double(length(con_pts))
for(i in 1:length(con_pts)) pat_index[i] = min(which(data_chan[,'patient']==con_pts[i]))
## PRIORS
mu1_mean = c(1,1.5)
mu2_mean = mu1_mean
mu1_prec = solve( matrix(c(0.2,0.1,0.1,0.2), ncol=2, nrow=2, byrow=TRUE) )
mu2_prec = solve( 5*diag(2) )
U_1 = matrix( c(10,7,7,10), ncol=2, nrow=2, byrow=TRUE)
n_1 = 50
U_2 = 3*diag(2)
n_2 = 20
alpha = 1
beta = 1
data = list(Y=Ychan, N=N, pat_index=pat_index,
mu1_mean=mu1_mean, mu1_prec=mu1_prec,
mu2_mean=mu2_mean, mu2_prec=mu2_prec, n_1=n_1, n_2=n_2,
U_1=U_1, U_2=U_2, alpha=alpha, beta=beta)
data_priorpred = data
data_priorpred$Y = NULL
data_priorpred$N = 0
model = jags.model(textConnection(modelstring), data=data, n.chains=n.chains)
model_priorpred = jags.model(textConnection(modelstring), data=data_priorpred)
update(model, n.iter=MCMCUpdates)
converge = coda.samples(model=model, variable.names=c("mu","tau","Y_syn","z","probdiff"),
n.iter=MCMCUpdates_Report, thin=MCMCUpdates_Thin)
output = coda.samples(model=model, variable.names=c("mu", "tau","Y_syn","z","probdiff"),
n.iter=MCMCUpdates_Report, thin=MCMCUpdates_Thin)
output_priorpred = coda.samples(model=model_priorpred,
variable.names=c("mu", "tau","Y_syn","z","probdiff"),
n.iter=MCMCUpdates_Report, thin=MCMCUpdates_Thin)
MCMCoutput = output[,c("mu[1,1]","mu[1,2]","mu[2,1]","mu[2,2]",
"tau[1,1,1]","tau[1,2,1]","tau[2,1,1]","tau[2,2,1]",
"tau[1,1,2]","tau[1,2,2]","tau[2,1,2]","tau[2,2,2]",
"probdiff[1]", "probdiff[2]","probdiff[3]","probdiff[4]",
"probdiff[5]","probdiff[6]","probdiff[7]","probdiff[8]",
"probdiff[9]","probdiff[10]","Y_syn[1]", "Y_syn[2]")]
posterior = as.data.frame(output[[1]])
prior = as.data.frame(output_priorpred[[1]])
classifs = colMeans( posterior[, grepl('z', colnames(posterior))] )
colnames(posterior) = colnames(output[[1]])
colnames(prior) = colnames(output_priorpred[[1]])
pat_ind = c(0,N)
pat_ind = cumsum(pat_ind)
for(i in 1:length(N)){
pat = c('CTRL', pts)[i]
class_pat = classifs[(pat_ind[i]+1):pat_ind[i+1]]
write.table(as.numeric(classifs),file.path("Output/Output_allData",paste(outroot, pts[i], "CLASS.txt", sep='__')),
row.names=FALSE,quote=FALSE,col.names=FALSE)
data_pat = data_chan[(pat_ind[i]+1):pat_ind[i+1], ]
pdf(file.path("PDF/PDF_allData/classification", paste(outroot,".pdf")), width=14,height=8.5)
if( pat=='CTRL'){
priorpost( data=data_pat, prior=prior, posterior=posterior,
classifs=class_pat, title=paste(froot, pat[i], chan))
} else {
priorpost( data=data_pat, prior=prior, posterior=posterior, ctrl=data_ctrl,
classifs=class_pat, title=paste(froot, pat[i], chan))
}
pdf(file.path("PDF/PDF_allData/MCMC_output", paste(outroot,".pdf")), width=14,height=8.5)
dev.off()
}
write.table(posterior[,c("mu[1,1]","mu[1,2]","mu[2,1]","mu[2,2]",
"tau[1,1,1]","tau[1,2,1]","tau[2,1,1]","tau[2,2,1]",
"tau[1,1,2]","tau[1,2,2]","tau[2,1,2]","tau[2,2,2]",
"probdiff[1]","probdiff[2]","probdiff[3]","probdiff[4]",
"probdiff[5]","probdiff[6]","probdiff[7]","probdiff[8]",
"probdiff[9]","probdiff[10]","Y_syn[1]", "Y_syn[2]")],
posterior_file, row.names=FALSE, quote=FALSE)
}
posterior
for(i in 1:length(N)){
pat = c('CTRL', pts)[i]
class_pat = classifs[(pat_ind[i]+1):pat_ind[i+1]]
write.table(as.numeric(classifs),file.path("Output/Output_allData",paste(outroot, pts[i], "CLASS.txt", sep='__')),
row.names=FALSE,quote=FALSE,col.names=FALSE)
data_pat = data_chan[(pat_ind[i]+1):pat_ind[i+1], ]
pdf(file.path("PDF/PDF_allData/classification", paste(outroot,".pdf")), width=14,height=8.5)
if( pat=='CTRL'){
priorpost( data=data_pat, prior=prior, posterior=posterior,
classifs=class_pat, title=paste(froot, pat[i], chan))
} else {
priorpost( data=data_pat, prior=prior, posterior=posterior, ctrl=data_ctrl,
classifs=class_pat, title=paste(froot, pat[i], chan))
}
pdf(file.path("PDF/PDF_allData/MCMC_output", paste(outroot,".pdf")), width=14,height=8.5)
dev.off()
}
warnings()
priorpost = function(data, prior, posterior, classifs, ctrl=NULL,
output_mcmc=NULL, title, marginals=FALSE){
# output: plots the prior and posterior regression lines and data
op = par(mfrow=c(1,2), mar = c(5.5,5.5,3,3))
if( is.null(ctrl) ){
x.lim = range(data[,1]) + c(-1,1)
y.lim = range(data[,2]) + c(-1,1)
plot(data[,1], data[,2], col=myDarkGrey, pch=20, cex.axis=1.5,
xlab=paste("log(",mitochan,")"), ylab=paste("log(",chan,")"), main='Prior Predictive',
xlim=x.lim, ylim=y.lim)
contour( kde2d(prior[,'Y_syn[1]'], prior[,'Y_syn[2]'], n=100), add=TRUE, nlevels=5 )
plot(data[,1], data[,2], col=myDarkGrey, pch=20, cex.axis=1.5,
xlab=paste("log(",mitochan,")"), ylab=paste("log(",chan,")"), main='Prior Predictive',
xlim=x.lim, ylim=y.lim)
contour( kde2d(posterior[,'Y_syn[1]'], posterior[,'Y_syn[2]'], n=100), add=TRUE, nlevels=5 )
title(main=title, line = -1, outer = TRUE)
} else {
x.lim = range( data[,1], ctrl[,1] ) + c(-1,1)
y.lim = range( data[,2], ctrl[,2] ) + c(-1,1)
plot(ctrl[,1], ctrl[,2], col=myDarkGrey, pch=20, cex.axis=1.5,
xlab=paste("log(",mitochan,")"), ylab=paste("log(",chan,")"), main='Prior Predictive',
xlim=x.lim, ylim=y.lim)
points( data[,1], data[,2], col=myYellow, pch=20)
contour( kde2d(prior[,'Y_syn[1]'], prior[,'Y_syn[2]'], n=100), add=TRUE, nlevels=5 )
plot(ctrl[,1], ctrl[,2], col=myDarkGrey, pch=20, cex.axis=1.5,
xlab=paste("log(",mitochan,")"), ylab=paste("log(",chan,")"), main='Prior Predictive',
xlim=x.lim, ylim=y.lim)
points( data[,1], data[,2], col=classcols(classifs), pch=20)
contour( kde2d(posterior[,'Y_syn[1]'], posterior[,'Y_syn[2]'], n=100), add=TRUE, nlevels=5 )
title(main=title, line = -1, outer = TRUE)
}
par(op)
}
classifs
for(i in 1:length(N)){
pat = c('CTRL', pts)[i]
class_pat = classifs[(pat_ind[i]+1):pat_ind[i+1]]
write.table(as.numeric(classifs),file.path("Output/Output_allData",paste(outroot, pts[i], "CLASS.txt", sep='__')),
row.names=FALSE,quote=FALSE,col.names=FALSE)
data_pat = data_chan[(pat_ind[i]+1):pat_ind[i+1], ]
pdf(file.path("PDF/PDF_allData/classification", paste(outroot,".pdf")), width=14,height=8.5)
if( pat=='CTRL'){
priorpost( data=data_pat, prior=prior, posterior=posterior,
classifs=class_pat, title=paste(froot, pat[i], chan))
} else {
priorpost( data=data_pat, prior=prior, posterior=posterior, ctrl=data_ctrl,
classifs=class_pat, title=paste(froot, pat[i], chan))
}
pdf(file.path("PDF/PDF_allData/MCMC_output", paste(outroot,".pdf")), width=14,height=8.5)
dev.off()
}
write.table(posterior[,c("mu[1,1]","mu[1,2]","mu[2,1]","mu[2,2]",
"tau[1,1,1]","tau[1,2,1]","tau[2,1,1]","tau[2,2,1]",
"tau[1,1,2]","tau[1,2,2]","tau[2,1,2]","tau[2,2,2]",
"probdiff[1]","probdiff[2]","probdiff[3]","probdiff[4]",
"probdiff[5]","probdiff[6]","probdiff[7]","probdiff[8]",
"probdiff[9]","probdiff[10]","Y_syn[1]", "Y_syn[2]")],
posterior_file, row.names=FALSE, quote=FALSE)
paste('hello', 'world')
paste0('hello', 'wolrd')
for( j in 1:length(pts) ){
# all the patient data for chan
patient = imcDat[(imcDat$patient_id==pts[j])&(imcDat$type=="mean intensity"), ]
# patient data
Xpat = log(patient$value[patient$channel==mitochan])
Ypat = log(patient$value[patient$channel==chan])
Npat = length(Xpat)
# add patient data to data matrix
Xchan = c(Xchan, Xpat)
Ychan = c(Ychan, Ypat)
patient_id = c(patient_id, rep(paste(pts[j]), Npat) )
N[j+1] = Npat
}
for(i in 1:length(N)){
pat = c('CTRL', pts)[i]
class_pat = classifs[(pat_ind[i]+1):pat_ind[i+1]]
write.table(as.numeric(classifs),file.path("Output/Output_allData",paste0(outroot, pts[i], "CLASS.txt", sep='__')),
row.names=FALSE,quote=FALSE,col.names=FALSE)
data_pat = data_chan[(pat_ind[i]+1):pat_ind[i+1], ]
pdf(file.path("PDF/PDF_allData/classification", paste0(outroot,".pdf")), width=14,height=8.5)
if( pat=='CTRL'){
priorpost( data=data_pat, prior=prior, posterior=posterior,
classifs=class_pat, title=paste0(froot, pat[i], chan))
} else {
priorpost( data=data_pat, prior=prior, posterior=posterior, ctrl=data_ctrl,
classifs=class_pat, title=paste0(froot, pat[i], chan))
}
pdf(file.path("PDF/PDF_allData/MCMC_output", paste0(outroot,".pdf")), width=14,height=8.5)
dev.off()
}
paste0('hello', 'world', sep='__')
paste('h', 'w', sep='__')
# for( chan in imc_chan[-!(imc_chan == mitochan)]){
for( chan in c('NDUFB8')){
outroot = paste( froot, chan, sep='__')
posterior_file = file.path("Output/Output_allData", paste0(outroot, "__POSTERIOR.txt") )
# dataset with only the current protein and VDAC1
data_chan = imcDat[(imcDat$channel==chan)|(imcDat$channel==mitochan),]
# control data for chan
control = imcDat[(imcDat$patient_type=='control')&(imcDat$type=='mean intensity'), ]
Xctrl = log(control$value[control$channel==mitochan])
Yctrl = log(control$value[control$channel==chan])
Nctrl = length(Yctrl)
Xchan = Xctrl
Ychan = Yctrl
patient_id = rep('control', Nctrl)
data_ctrl = data.frame(Xctrl, Yctrl,  rep('control', Nctrl))
colnames(data_ctrl) = c(mitochan, chan, 'patient')
N = double(10) # store the number of observations per patient
N[1] = Nctrl
for( j in 1:length(pts) ){
# all the patient data for chan
patient = imcDat[(imcDat$patient_id==pts[j])&(imcDat$type=="mean intensity"), ]
# patient data
Xpat = log(patient$value[patient$channel==mitochan])
Ypat = log(patient$value[patient$channel==chan])
Npat = length(Xpat)
# add patient data to data matrix
Xchan = c(Xchan, Xpat)
Ychan = c(Ychan, Ypat)
patient_id = c(patient_id, rep(paste(pts[j]), Npat) )
N[j+1] = Npat
}
# make data frame from data matrix
data_chan = data.frame(Xchan, Ychan, patient_id)
colnames(data_chan) = c(mitochan, chan, 'patient')
# saving output for mcmc
Ychan = data_chan[,c(mitochan, chan)]
is_control = as.numeric( patient_id=="control" )
# row index for each change in patient
con_pts = c('control', pts)
pat_index = double(length(con_pts))
for(i in 1:length(con_pts)) pat_index[i] = min(which(data_chan[,'patient']==con_pts[i]))
## PRIORS
mu1_mean = c(1,1.5)
mu2_mean = mu1_mean
mu1_prec = solve( matrix(c(0.2,0.1,0.1,0.2), ncol=2, nrow=2, byrow=TRUE) )
mu2_prec = solve( 5*diag(2) )
U_1 = matrix( c(10,7,7,10), ncol=2, nrow=2, byrow=TRUE)
n_1 = 50
U_2 = 3*diag(2)
n_2 = 20
alpha = 1
beta = 1
data = list(Y=Ychan, N=N, pat_index=pat_index,
mu1_mean=mu1_mean, mu1_prec=mu1_prec,
mu2_mean=mu2_mean, mu2_prec=mu2_prec, n_1=n_1, n_2=n_2,
U_1=U_1, U_2=U_2, alpha=alpha, beta=beta)
data_priorpred = data
data_priorpred$Y = NULL
data_priorpred$N = 0
model = jags.model(textConnection(modelstring), data=data, n.chains=n.chains)
model_priorpred = jags.model(textConnection(modelstring), data=data_priorpred)
update(model, n.iter=MCMCUpdates)
converge = coda.samples(model=model, variable.names=c("mu","tau","Y_syn","z","probdiff"),
n.iter=MCMCUpdates_Report, thin=MCMCUpdates_Thin)
output = coda.samples(model=model, variable.names=c("mu", "tau","Y_syn","z","probdiff"),
n.iter=MCMCUpdates_Report, thin=MCMCUpdates_Thin)
output_priorpred = coda.samples(model=model_priorpred,
variable.names=c("mu", "tau","Y_syn","z","probdiff"),
n.iter=MCMCUpdates_Report, thin=MCMCUpdates_Thin)
MCMCoutput = output[,c("mu[1,1]","mu[1,2]","mu[2,1]","mu[2,2]",
"tau[1,1,1]","tau[1,2,1]","tau[2,1,1]","tau[2,2,1]",
"tau[1,1,2]","tau[1,2,2]","tau[2,1,2]","tau[2,2,2]",
"probdiff[1]", "probdiff[2]","probdiff[3]","probdiff[4]",
"probdiff[5]","probdiff[6]","probdiff[7]","probdiff[8]",
"probdiff[9]","probdiff[10]","Y_syn[1]", "Y_syn[2]")]
posterior = as.data.frame(output[[1]])
prior = as.data.frame(output_priorpred[[1]])
classifs = colMeans( posterior[, grepl('z', colnames(posterior))] )
colnames(posterior) = colnames(output[[1]])
colnames(prior) = colnames(output_priorpred[[1]])
pat_ind = c(0,N)
pat_ind = cumsum(pat_ind)
for(i in 1:length(N)){
pat = c('CTRL', pts)[i]
class_pat = classifs[(pat_ind[i]+1):pat_ind[i+1]]
write.table(as.numeric(classifs),file.path("Output/Output_allData",paste(outroot, pts[i], "CLASS.txt", sep='__')),
row.names=FALSE,quote=FALSE,col.names=FALSE)
data_pat = data_chan[(pat_ind[i]+1):pat_ind[i+1], ]
pdf(file.path("PDF/PDF_allData/classification", paste0(outroot,".pdf")), width=14,height=8.5)
if( pat=='CTRL'){
priorpost( data=data_pat, prior=prior, posterior=posterior,
classifs=class_pat, title=paste0(froot, pat[i], chan))
} else {
priorpost( data=data_pat, prior=prior, posterior=posterior, ctrl=data_ctrl,
classifs=class_pat, title=paste0(froot, pat[i], chan))
}
pdf(file.path("PDF/PDF_allData/MCMC_output", paste0(outroot,".pdf")), width=14,height=8.5)
dev.off()
}
write.table(posterior[,c("mu[1,1]","mu[1,2]","mu[2,1]","mu[2,2]",
"tau[1,1,1]","tau[1,2,1]","tau[2,1,1]","tau[2,2,1]",
"tau[1,1,2]","tau[1,2,2]","tau[2,1,2]","tau[2,2,2]",
"probdiff[1]","probdiff[2]","probdiff[3]","probdiff[4]",
"probdiff[5]","probdiff[6]","probdiff[7]","probdiff[8]",
"probdiff[9]","probdiff[10]","Y_syn[1]", "Y_syn[2]")],
posterior_file, row.names=FALSE, quote=FALSE)
}
priorpost( data=data_pat, prior=prior, posterior=posterior, ctrl=data_ctrl,
classifs=class_pat, title=paste0(froot, pat[i], chan))
save.image("~/Documents/GitHub/fibre_classification/GMM/GMM_patData/temp_200721.RData")
for(i in 1:length(N)){
pat = c('CTRL', pts)[i]
class_pat = classifs[(pat_ind[i]+1):pat_ind[i+1]]
write.table(as.numeric(classifs),file.path("Output/Output_allData",paste(outroot, pts[i], "CLASS.txt", sep='__')),
row.names=FALSE,quote=FALSE,col.names=FALSE)
data_pat = data_chan[(pat_ind[i]+1):pat_ind[i+1], ]
pdf(file.path("PDF/PDF_allData/classification", paste0(outroot,".pdf")), width=14,height=8.5)
if( pat=='CTRL'){
priorpost( data=data_pat, prior=prior, posterior=posterior,
classifs=class_pat, title=paste0(froot, pat[i], chan))
} else {
priorpost( data=data_pat, prior=prior, posterior=posterior, ctrl=data_ctrl,
classifs=class_pat, title=paste0(froot, pat[i], chan))
}
pdf(file.path("PDF/PDF_allData/MCMC_output", paste0(outroot,".pdf")), width=14,height=8.5)
dev.off()
}
?traceplot
posterior
MCMCoutput
for(i in 1:length(N)) {
pat = c('CTRL', pts)[i]
class_pat = classifs[(pat_ind[i]+1):pat_ind[i+1]]
write.table(as.numeric(classifs),file.path("Output/Output_allData",paste(outroot, pts[i], "CLASS.txt", sep='__')),
row.names=FALSE,quote=FALSE,col.names=FALSE)
data_pat = data_chan[(pat_ind[i]+1):pat_ind[i+1], ]
if( pat=='CTRL'){
pdf(file.path("PDF/PDF_allData/classification", paste0(outroot,".pdf")), width=14,height=8.5)
priorpost( data=data_pat, prior=prior, posterior=posterior,
classifs=class_pat, title=paste0(froot, pat[i], chan))
dev.off()
} else {
pdf(file.path("PDF/PDF_allData/classification", paste0(outroot,".pdf")), width=14,height=8.5)
priorpost( data=data_pat, prior=prior, posterior=posterior, ctrl=data_ctrl,
classifs=class_pat, title=paste0(froot, pat[i], chan))
dev.off()
}
pdf(file.path("PDF/PDF_allData/MCMC_output", paste0(outroot,".pdf")), width=14,height=8.5)
plot(MCMCoutput)
dev.off()
}
# plots for each patient
for(i in 1:length(N)) {
pat = c('CTRL', pts)[i]
class_pat = classifs[(pat_ind[i]+1):pat_ind[i+1]]
write.table(as.numeric(classifs),file.path("Output/Output_allData",paste(outroot, pts[i], "CLASS.txt", sep='__')),
row.names=FALSE,quote=FALSE,col.names=FALSE)
data_pat = data_chan[(pat_ind[i]+1):pat_ind[i+1], ]
if( pat=='CTRL'){
pdf(file.path("PDF/PDF_allData/classification", paste0(outroot,".pdf")), width=14,height=8.5)
priorpost( data=data_pat, prior=prior, posterior=posterior,
classifs=class_pat, title=paste0(froot, pat[i], chan))
dev.off()
} else {
pdf(file.path("PDF/PDF_allData/classification", paste0(outroot,".pdf")), width=14,height=8.5)
priorpost( data=data_pat, prior=prior, posterior=posterior, ctrl=data_ctrl,
classifs=class_pat, title=paste0(froot, pat[i], chan))
dev.off()
}
}
# plots for each patient
for(i in 1:length(N)) {
pat = c('CTRL', pts)[i]
class_pat = classifs[(pat_ind[i]+1):pat_ind[i+1]]
write.table(as.numeric(classifs),file.path("Output/Output_allData",paste(outroot, pts[i], "CLASS.txt", sep='__')),
row.names=FALSE,quote=FALSE,col.names=FALSE)
data_pat = data_chan[(pat_ind[i]+1):pat_ind[i+1], ]
if( pat=='CTRL'){
pdf(file.path("PDF/PDF_allData/classification", paste0(outroot, pat[i], ".pdf")), width=14,height=8.5)
priorpost( data=data_pat, prior=prior, posterior=posterior,
classifs=class_pat, title=paste0(froot, pat[i], chan))
dev.off()
} else {
pdf(file.path("PDF/PDF_allData/classification", paste0(outroot,pat[i], ".pdf")), width=14,height=8.5)
priorpost( data=data_pat, prior=prior, posterior=posterior, ctrl=data_ctrl,
classifs=class_pat, title=paste0(froot, pat[i], chan))
dev.off()
}
}
# plots for each patient
for(i in 1:length(N)) {
pat = c('CTRL', pts)[i]
class_pat = classifs[(pat_ind[i]+1):pat_ind[i+1]]
write.table(as.numeric(classifs),file.path("Output/Output_allData",paste(outroot, pts[i], "CLASS.txt", sep='__')),
row.names=FALSE,quote=FALSE,col.names=FALSE)
data_pat = data_chan[(pat_ind[i]+1):pat_ind[i+1], ]
if( pat=='CTRL'){
pdf(file.path("PDF/PDF_allData/classification", paste0(paste(outroot, pat[i], sep='__'), ".pdf")), width=14,height=8.5)
priorpost( data=data_pat, prior=prior, posterior=posterior,
classifs=class_pat, title=paste0(froot, pat[i], chan))
dev.off()
} else {
pdf(file.path("PDF/PDF_allData/classification", paste0(paste(outroot,pat[i], sep="__"), ".pdf")), width=14,height=8.5)
priorpost( data=data_pat, prior=prior, posterior=posterior, ctrl=data_ctrl,
classifs=class_pat, title=paste0(froot, pat[i], chan))
dev.off()
}
}
# plots for each patient
for(i in 1:length(N)) {
pat = c('CTRL', pts)[i]
class_pat = classifs[(pat_ind[i]+1):pat_ind[i+1]]
write.table(as.numeric(classifs),file.path("Output/Output_allData",paste(outroot, pts[i], "CLASS.txt", sep='__')),
row.names=FALSE,quote=FALSE,col.names=FALSE)
data_pat = data_chan[(pat_ind[i]+1):pat_ind[i+1], ]
if( pat=='CTRL'){
pdf(file.path("PDF/PDF_allData/classification", paste0(paste(outroot, pat, sep='__'), ".pdf")), width=14,height=8.5)
priorpost( data=data_pat, prior=prior, posterior=posterior,
classifs=class_pat, title=paste0(froot, pat[i], chan))
dev.off()
} else {
pdf(file.path("PDF/PDF_allData/classification", paste0(paste(outroot, pat, sep="__"), ".pdf")), width=14,height=8.5)
priorpost( data=data_pat, prior=prior, posterior=posterior, ctrl=data_ctrl,
classifs=class_pat, title=paste0(froot, pat[i], chan))
dev.off()
}
}
pdf(file.path("PDF/PDF_allData/MCMC_output", paste0(outroot,".pdf")), width=14,height=8.5)
plot(MCMCoutput)
dev.off()
densityplot(MCMCoutput)
autocorr.plot(MCMCoutput)
dev.off()
autocorr.plot(MCMCoutput)
MCMCoutput
plot(MCMCoutput)
par(mfrow=c(1,1))
plot(MCMCoutput)
save.image("~/Documents/GitHub/fibre_classification/GMM/GMM_patData/temp_200721.RData")
MCMCplot = function( MCMCoutput ){
p = ncol(MCMCoutput)
col.names = colnames(MCMCoutput[[1]])
par(mfrow=c(3,3), mar = c(5.5,5.5,3,3))
for(param in col.names){
autocorr.plot(MCMCoutput[,param])
traceplot(MCMCoutput[,param])
plot(density(MCMCoutput[[1]][,param]))
}
}
MCMCplot(MCMCoutput)
save.image("~/Documents/GitHub/fibre_classification/GMM/GMM_patData/temp_200721.RData")
